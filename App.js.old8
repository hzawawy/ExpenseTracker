// Enhanced OCR Implementation with Multiple Options
import React, { useState, useEffect } from 'react';
import {
  SafeAreaView,
  ScrollView,
  StatusBar,
  StyleSheet,
  Text,
  View,
  TouchableOpacity,
  TextInput,
  Alert,
  Modal,
  Image,
  Dimensions,
  PermissionsAndroid,
  Platform,
} from 'react-native';
import {launchImageLibrary, launchCamera} from 'react-native-image-picker';

// OPTION 1: Tesseract OCR (More Accurate)
import TesseractOcr, { LANG_ENGLISH } from 'react-native-tesseract-ocr';

// OPTION 2: Vision Camera with OCR (Real-time, Most Accurate)
// import { Camera, useCameraDevices, useFrameProcessor } from 'react-native-vision-camera';
// import { scanOCR } from 'vision-camera-ocr';

// OPTION 3: Document Scanner (Best for Receipts)
// import DocumentScanner from 'react-native-document-scanner-plugin';

// OPTION 4: Google ML Kit (Current - keeping as fallback)
import TextRecognition from '@react-native-ml-kit/text-recognition';

const { width } = Dimensions.get('window');

const App = () => {
  const [activeTab, setActiveTab] = useState('dashboard');
  const [transactions, setTransactions] = useState([]);
  const [recurringIncome, setRecurringIncome] = useState([]);
  const [scannedReceipts, setScannedReceipts] = useState([]);
  const [startingBalance, setStartingBalance] = useState(0);
  const [showStartingBalanceModal, setShowStartingBalanceModal] = useState(false);
  const [balanceInput, setBalanceInput] = useState('');
  const [isProcessingReceipt, setIsProcessingReceipt] = useState(false);
  const [selectedOcrEngine, setSelectedOcrEngine] = useState('tesseract'); // tesseract, mlkit, vision, document
  
  const [newTransaction, setNewTransaction] = useState({
    amount: '', category: '', description: '', type: 'expense', isRecurring: false, frequency: 'monthly'
  });

  const [showDeleteModal, setShowDeleteModal] = useState(false);
  const [selectedTransaction, setSelectedTransaction] = useState(null);
  const [showReceiptsModal, setShowReceiptsModal] = useState(false);
  const [showReportsModal, setShowReportsModal] = useState(false);
  const [showMultipleItemsModal, setShowMultipleItemsModal] = useState(false);
  const [showReceiptDetailModal, setShowReceiptDetailModal] = useState(false);
  const [showOcrSettingsModal, setShowOcrSettingsModal] = useState(false);
  const [selectedReceipt, setSelectedReceipt] = useState(null);
  const [extractedItems, setExtractedItems] = useState([]);

  const categories = {
    expense: ['Food', 'Transport', 'Shopping', 'Entertainment', 'Health', 'Bills', 'Other'],
    income: ['Salary', 'Freelance', 'Investment', 'Business', 'Gift', 'Other']
  };

  const frequencies = ['daily', 'weekly', 'monthly', 'yearly'];

  const ocrEngines = [
    { id: 'tesseract', name: 'Tesseract OCR', description: 'Most accurate for receipts', accuracy: '95%' },
    { id: 'mlkit', name: 'Google ML Kit', description: 'Fast but less accurate', accuracy: '75%' },
    { id: 'vision', name: 'Vision Camera', description: 'Real-time processing', accuracy: '90%' },
    { id: 'document', name: 'Document Scanner', description: 'Best for structured docs', accuracy: '92%' }
  ];

  // OPTION 1: Tesseract OCR Implementation (RECOMMENDED)
  const performTesseractOCR = async (imageUri) => {
    try {
      console.log('Starting Tesseract OCR for:', imageUri);
      
      // Tesseract configuration for receipts
      const tessOptions = {
        whitelist: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz$.,- ',
        blacklist: '', // Remove problematic characters
        // PSM modes: 3=Fully automatic page segmentation, 6=Uniform block of text, 8=Single word
        psm: 6, // Good for receipt structure
        // OEM modes: 3=Default+LSTM, 1=Neural nets LSTM only
        oem: 3
      };

      const recognizedText = await TesseractOcr.recognize(imageUri, LANG_ENGLISH, tessOptions);
      
      console.log('Tesseract OCR completed');
      console.log('Recognized text:', recognizedText);
      console.log('Text length:', recognizedText?.length || 0);
      
      if (recognizedText && recognizedText.trim().length > 0) {
        return {
          text: recognizedText,
          confidence: 0.95, // Tesseract typically high confidence
          engine: 'Tesseract OCR'
        };
      } else {
        throw new Error('No text detected by Tesseract');
      }
      
    } catch (error) {
      console.error('Tesseract OCR Error:', error);
      throw error;
    }
  };

  // OPTION 2: Vision Camera OCR (Uncomment when library is installed)
  /*
  const performVisionCameraOCR = async (imageUri) => {
    try {
      console.log('Starting Vision Camera OCR for:', imageUri);
      
      // This would typically be used with frame processors for real-time OCR
      // For static images, we'd need to process differently
      const result = await scanOCR(imageUri, {
        language: 'en',
        orientation: 'auto'
      });
      
      console.log('Vision Camera OCR completed');
      console.log('Detected text:', result.text);
      
      if (result.text && result.text.trim().length > 0) {
        return {
          text: result.text,
          confidence: result.confidence || 0.9,
          engine: 'Vision Camera OCR',
          blocks: result.blocks || []
        };
      } else {
        throw new Error('No text detected by Vision Camera');
      }
      
    } catch (error) {
      console.error('Vision Camera OCR Error:', error);
      throw error;
    }
  };
  */

  // OPTION 3: Document Scanner OCR (Uncomment when library is installed)
  /*
  const performDocumentScannerOCR = async () => {
    try {
      console.log('Starting Document Scanner OCR');
      
      const { scannedImages } = await DocumentScanner.scanDocument({
        maxNumDocuments: 1,
        letUserAdjustCrop: true,
        croppedImageQuality: 100,
        responseType: 'imageFilePath'
      });
      
      if (scannedImages && scannedImages.length > 0) {
        const imageUri = scannedImages[0];
        
        // Use Tesseract on the processed document image
        const recognizedText = await TesseractOcr.recognize(imageUri, LANG_ENGLISH, {
          whitelist: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz$.,- ',
          psm: 6,
          oem: 3
        });
        
        return {
          text: recognizedText,
          confidence: 0.92,
          engine: 'Document Scanner + Tesseract',
          imageUri: imageUri
        };
      } else {
        throw new Error('No document scanned');
      }
      
    } catch (error) {
      console.error('Document Scanner OCR Error:', error);
      throw error;
    }
  };
  */

  // OPTION 4: Google ML Kit (Current implementation - kept as fallback)
  const performMLKitOCR = async (imageUri) => {
    try {
      console.log('Starting ML Kit OCR for:', imageUri);
      
      const result = await TextRecognition.recognize(imageUri);
      
      console.log('ML Kit OCR completed');
      console.log('Detected text:', result.text);
      
      if (result.text && result.text.trim().length > 0) {
        return {
          text: result.text,
          blocks: result.blocks || [],
          confidence: result.confidence || 0.75,
          engine: 'Google ML Kit'
        };
      } else {
        throw new Error('No text detected by ML Kit');
      }
      
    } catch (error) {
      console.error('ML Kit OCR Error:', error);
      throw error;
    }
  };

  // Smart OCR Engine Selector
  const performSmartOCR = async (imageUri) => {
    const engines = [];
    
    // Add available engines based on what's installed
    if (selectedOcrEngine === 'tesseract') {
      engines.push(() => performTesseractOCR(imageUri));
    }
    /*
    if (selectedOcrEngine === 'vision') {
      engines.push(() => performVisionCameraOCR(imageUri));
    }
    if (selectedOcrEngine === 'document') {
      engines.push(() => performDocumentScannerOCR());
    }
    */
    
    // Always have ML Kit as fallback
    engines.push(() => performMLKitOCR(imageUri));
    
    // Try engines in order of preference
    for (const engine of engines) {
      try {
        const result = await engine();
        if (result && result.text && result.text.length > 20) { // Minimum viable text length
          return result;
        }
      } catch (error) {
        console.log('Engine failed, trying next...', error.message);
        continue;
      }
    }
    
    throw new Error('All OCR engines failed to extract meaningful text');
  };

  // Image preprocessing for better OCR results
  const preprocessImageForOCR = async (imageUri) => {
    // This would ideally use react-native-image-manipulator or similar
    // to enhance the image before OCR processing
    /*
    const manipulatedImage = await ImageManipulator.manipulateAsync(
      imageUri,
      [
        { resize: { width: 1200 } }, // Standardize size
        { rotate: 0 }, // Ensure proper orientation
        // Could add: contrast, brightness, sharpness adjustments
      ],
      {
        compress: 0.9,
        format: ImageManipulator.SaveFormat.JPEG,
      }
    );
    return manipulatedImage.uri;
    */
    return imageUri; // Return original for now
  };

  const requestCameraPermission = async () => {
    if (Platform.OS === 'android') {
      try {
        const granted = await PermissionsAndroid.requestMultiple([
          PermissionsAndroid.PERMISSIONS.CAMERA,
          PermissionsAndroid.PERMISSIONS.READ_EXTERNAL_STORAGE,
          PermissionsAndroid.PERMISSIONS.WRITE_EXTERNAL_STORAGE,
        ]);
        
        const allPermissionsGranted = Object.values(granted).every(
          permission => permission === PermissionsAndroid.RESULTS.GRANTED
        );
        
        return allPermissionsGranted;
      } catch (err) {
        console.warn(err);
        return false;
      }
    }
    return true;
  };

  const addTransaction = () => {
    if (!newTransaction.amount || !newTransaction.category || !newTransaction.description) {
      Alert.alert('Error', 'Please fill in all fields');
      return;
    }

    if (newTransaction.isRecurring && newTransaction.type === 'income') {
      const recurringItem = {
        id: Date.now(),
        amount: parseFloat(newTransaction.amount),
        category: newTransaction.category,
        description: newTransaction.description,
        frequency: newTransaction.frequency,
        startDate: new Date().toISOString().split('T')[0],
        lastProcessed: null
      };
      setRecurringIncome(prev => [...prev, recurringItem]);
      Alert.alert('Success', 'Recurring income added!');
    } else {
      const transaction = {
        id: Date.now(),
        amount: parseFloat(newTransaction.amount),
        category: newTransaction.category,
        description: newTransaction.description,
        date: new Date().toISOString().split('T')[0],
        type: newTransaction.type,
        isRecurring: false
      };
      setTransactions(prev => [...prev, transaction]);
      Alert.alert('Success', 'Transaction added!');
    }

    setNewTransaction({ amount: '', category: '', description: '', type: 'expense', isRecurring: false, frequency: 'monthly' });
  };

  const deleteTransaction = (id) => {
    setTransactions(prev => prev.filter(t => t.id !== id));
    setShowDeleteModal(false);
    Alert.alert('Success', 'Transaction deleted!');
  };

  const deleteRecurring = (id) => {
    setRecurringIncome(prev => prev.filter(r => r.id !== id));
    Alert.alert('Success', 'Recurring income removed!');
  };

  const setInitialBalance = () => {
    if (balanceInput.trim() === '') {
      Alert.alert('Error', 'Please enter a balance amount');
      return;
    }
    const balance = parseFloat(balanceInput) || 0;
    setStartingBalance(balance);
    setShowStartingBalanceModal(false);
    setBalanceInput('');
    Alert.alert('Success', `Starting balance set to $${balance.toFixed(2)}`);
  };

  const scanReceipt = async () => {
    const hasPermission = await requestCameraPermission();
    if (!hasPermission) {
      Alert.alert('Permission Required', 'Camera permission is needed to scan receipts');
      return;
    }

    Alert.alert(
      'Smart Receipt Scanner',
      `Using ${ocrEngines.find(e => e.id === selectedOcrEngine)?.name || 'Default'} OCR Engine`,
      [
        { text: 'Camera', onPress: () => openCamera() },
        { text: 'Gallery', onPress: () => openGallery() },
        { text: 'Settings', onPress: () => setShowOcrSettingsModal(true) },
        { text: 'Cancel', style: 'cancel' }
      ]
    );
  };

  const openCamera = () => {
    const options = {
      mediaType: 'photo',
      quality: 0.95, // Higher quality for better OCR
      maxWidth: 1600,
      maxHeight: 2400,
      includeBase64: false,
    };
    
    launchCamera(options, (response) => {
      if (response.assets && response.assets[0]) {
        processReceiptImage(response.assets[0]);
      } else if (response.errorMessage) {
        Alert.alert('Camera Error', response.errorMessage);
      }
    });
  };

  const openGallery = () => {
    const options = {
      mediaType: 'photo',
      quality: 0.95,
      maxWidth: 1600,
      maxHeight: 2400,
      includeBase64: false,
    };
    
    launchImageLibrary(options, (response) => {
      if (response.assets && response.assets[0]) {
        processReceiptImage(response.assets[0]);
      } else if (response.errorMessage) {
        Alert.alert('Gallery Error', response.errorMessage);
      }
    });
  };

  const processReceiptImage = async (imageAsset) => {
    setIsProcessingReceipt(true);
    
    try {
      console.log('Processing receipt with Smart OCR System');
      
      // Preprocess image for better OCR results
      const processedImageUri = await preprocessImageForOCR(imageAsset.uri);
      
      // Use smart OCR engine selection
      const ocrResult = await performSmartOCR(processedImageUri);
      
      console.log(`OCR completed using ${ocrResult.engine}, confidence: ${ocrResult.confidence}`);
      console.log('Text length:', ocrResult.text.length);
      
      // Parse the extracted text with enhanced logic
      const parsedReceipt = parseReceiptTextAdvanced(ocrResult.text);
      
      const receipt = {
        id: Date.now(),
        image: imageAsset.uri,
        extractedText: ocrResult.text,
        blocks: ocrResult.blocks || [],
        parsedData: parsedReceipt,
        ocrMethod: ocrResult.engine,
        confidence: ocrResult.confidence,
        scanDate: new Date().toISOString().split('T')[0],
        processingTime: new Date().toISOString()
      };

      setScannedReceipts(prev => [...prev, receipt]);
      
      if (parsedReceipt.items && parsedReceipt.items.length > 1) {
        setExtractedItems(parsedReceipt.items);
        setShowMultipleItemsModal(true);
      } else if (parsedReceipt.items && parsedReceipt.items.length === 1) {
        const item = parsedReceipt.items[0];
        setNewTransaction({
          ...newTransaction,
          amount: item.amount.toString(),
          category: categorizeItem(item.description),
          description: item.description
        });
        setActiveTab('add');
        Alert.alert(
          '‚úÖ OCR Success!', 
          `${ocrResult.engine} found:\n${item.description} - $${item.amount.toFixed(2)}\n\nConfidence: ${Math.round(ocrResult.confidence * 100)}%`
        );
      } else {
        Alert.alert(
          'üìÑ OCR Completed', 
          `Engine: ${ocrResult.engine}\nConfidence: ${Math.round(ocrResult.confidence * 100)}%\nText: ${ocrResult.text.length} chars\n\nFound ${parsedReceipt.potentialItems?.length || 0} potential items\n\nTap receipt to view details`
        );
      }
      
    } catch (error) {
      console.error('Smart OCR Failed:', error);
      Alert.alert(
        '‚ùå OCR Failed', 
        `All OCR engines failed.\n\nError: ${error.message}\n\nüí° Tips:\n‚Ä¢ Use good lighting\n‚Ä¢ Hold camera steady\n‚Ä¢ Try different OCR engine in settings\n‚Ä¢ Ensure receipt text is clear`
      );
    } finally {
      setIsProcessingReceipt(false);
    }
  };

  // Advanced receipt parsing with multiple strategies
  const parseReceiptTextAdvanced = (text) => {
    const lines = text.split('\n').map(line => line.trim()).filter(line => line.length > 0);
    const items = [];
    const potentialItems = [];
    let total = 0;
    let merchant = '';
    let tax = 0;
    let subtotal = 0;
    
    console.log('Advanced parsing of text:', text.substring(0, 200) + '...');
    console.log('Lines found:', lines.length);
    
    // Enhanced merchant detection
    const merchantPatterns = [
      /^[A-Z\s&'.-]{3,30}$/,
      /^[A-Z][a-z\s&'.-]{3,30}$/,
      /^[A-Z]+[a-z]*\s+[A-Z]+[a-z]*$/
    ];
    
    for (let i = 0; i < Math.min(5, lines.length); i++) {
      const line = lines[i];
      if (line && !line.match(/\$\d/) && !line.match(/^\d+\.?\d*$/) && line.length > 2) {
        for (const pattern of merchantPatterns) {
          if (pattern.test(line)) {
            merchant = line;
            break;
          }
        }
        if (merchant) break;
      }
    }
    
    // Enhanced item detection with multiple strategies
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      
      if (!line || line.length < 2) continue;
      
      // Skip known non-item patterns
      const skipPatterns = [
        /^(receipt|thank\s*you|visit|welcome|store|location|phone|address|date|time|cashier|clerk)$/i,
        /^(subtotal|tax|total|change|cash|card|credit|debit|payment|balance|tender)$/i,
        /^[\d\s\-\/\:]+$/, // Date/time patterns
        /^store\s*#?\d+/i,
        /^\*+$/
      ];
      
      let shouldSkip = false;
      for (const pattern of skipPatterns) {
        if (pattern.test(line)) {
          shouldSkip = true;
          break;
        }
      }
      if (shouldSkip) continue;
      
      // Extract totals, subtotals, tax
      if (line.toLowerCase().includes('total') && !line.toLowerCase().includes('subtotal')) {
        const amounts = line.match(/\$?(\d+\.?\d{0,2})/g);
        if (amounts) {
          const nums = amounts.map(a => parseFloat(a.replace('$', ''))).filter(n => !isNaN(n) && n > 0);
          if (nums.length > 0) total = Math.max(...nums);
        }
        continue;
      }
      
      if (line.toLowerCase().includes('subtotal')) {
        const match = line.match(/\$?(\d+\.?\d{0,2})/);
        if (match) subtotal = parseFloat(match[1]);
        continue;
      }
      
      if (line.toLowerCase().includes('tax')) {
        const match = line.match(/\$?(\d+\.?\d{0,2})/);
        if (match) tax = parseFloat(match[1]);
        continue;
      }
      
      // Enhanced item detection patterns
      const itemPatterns = [
        // Standard item + price
        /^(.+?)\s+\$?(\d+\.?\d{0,2})$/,
        // Item with multiple spaces before price
        /^(.+?)\s{2,}(\d+\.?\d{0,2})$/,
        // Item with tab or special chars
        /^(.+?)[\t\s]+(\d+\.?\d{0,2})$/,
        // Item code + description + price
        /^\d+\s+(.+?)\s+(\d+\.?\d{0,2})$/,
        // Item with quantity
        /^(.+?)\s+\d+\s*x\s*(\d+\.?\d{0,2})$/,
        // Item @ price
        /^(.+?)\s*@\s*(\d+\.?\d{0,2})$/,
        // Item with dash separator
        /^(.+?)\s*-\s*(\d+\.?\d{0,2})$/
      ];
      
      let itemFound = false;
      for (const pattern of itemPatterns) {
        const match = line.match(pattern);
        if (match) {
          let description = match[1].trim();
          const amount = parseFloat(match[2]);
          
          // Clean up description
          description = description.replace(/^\d+\s*/, ''); // Remove leading numbers
          description = description.replace(/\s+/g, ' '); // Normalize spaces
          
          // Validate item
          if (description && 
              description.length >= 2 && 
              description.length <= 50 && 
              amount > 0 && 
              amount <= 1000 && // Reasonable max
              !description.toLowerCase().match(/^(tax|total|subtotal|change|cash|card|payment|balance|discount|coupon)$/i)) {
            
            items.push({
              description: description,
              amount: amount,
              category: categorizeItemAdvanced(description),
              selected: true,
              lineNumber: i + 1,
              confidence: calculateItemConfidence(description, amount, line)
            });
            itemFound = true;
            break;
          }
        }
      }
      
      // If no pattern matched but line looks promising, save as potential
      if (!itemFound && line.match(/[A-Za-z]/) && line.match(/\d/)) {
        potentialItems.push({
          text: line,
          lineNumber: i + 1,
          hasPrice: !!line.match(/\$?\d+\.?\d{0,2}/),
          hasLetters: !!line.match(/[A-Za-z]{3,}/)
        });
      }
    }
    
    // Sort items by confidence
    items.sort((a, b) => (b.confidence || 0) - (a.confidence || 0));
    
    console.log('Advanced parsing results:');
    console.log('- Merchant:', merchant);
    console.log('- Items found:', items.length);
    console.log('- Potential items:', potentialItems.length);
    console.log('- Total:', total);
    console.log('- Subtotal:', subtotal);
    console.log('- Tax:', tax);
    
    return {
      merchant: merchant || 'Unknown Store',
      items: items,
      potentialItems: potentialItems,
      total: total,
      subtotal: subtotal,
      tax: tax,
      date: new Date().toISOString().split('T')[0],
      rawLines: lines,
      confidence: items.length > 0 ? items.reduce((sum, item) => sum + (item.confidence || 0), 0) / items.length : 0
    };
  };

  // Calculate confidence score for detected items
  const calculateItemConfidence = (description, amount, fullLine) => {
    let confidence = 0.5; // Base confidence
    
    // Higher confidence for reasonable prices
    if (amount >= 1 && amount <= 100) confidence += 0.2;
    if (amount >= 0.5 && amount <= 50) confidence += 0.1;
    
    // Higher confidence for reasonable description length
    if (description.length >= 3 && description.length <= 25) confidence += 0.2;
    
    // Higher confidence if description contains food/product words
    const productWords = ['coffee', 'tea', 'food', 'sandwich', 'salad', 'pizza', 'burger', 'milk', 'bread', 'chip', 'soda', 'water'];
    if (productWords.some(word => description.toLowerCase().includes(word))) confidence += 0.1;
    
    // Lower confidence for suspicious patterns
    if (description.match(/^\d+$/)) confidence -= 0.3; // Just numbers
    if (description.length < 2) confidence -= 0.4; // Too short
    if (amount < 0.1 || amount > 500) confidence -= 0.3; // Unreasonable price
    
    return Math.max(0, Math.min(1, confidence));
  };

  const categorizeItemAdvanced = (description) => {
    const desc = description.toLowerCase();
    
    // Enhanced categorization with more specific patterns
    const categories = {
      'Food': [
        'milk', 'bread', 'egg', 'banana', 'apple', 'chicken', 'beef', 'fish', 'vegetable', 'fruit',
        'grocery', 'spinach', 'yogurt', 'cheese', 'pizza', 'burger', 'sandwich', 'salad', 'soup',
        'coffee', 'tea', 'soda', 'juice', 'water', 'beer', 'wine', 'restaurant', 'cafe', 'food',
        'snack', 'cereal', 'rice', 'pasta', 'meat', 'deli', 'bakery', 'produce', 'frozen',
        'beverage', 'drink', 'lunch', 'dinner', 'breakfast'
      ],
      'Transport': [
        'gas', 'fuel', 'unleaded', 'diesel', 'premium', 'parking', 'uber', 'lyft', 'taxi',
        'bus', 'train', 'metro', 'transport', 'travel', 'toll', 'fare', 'ticket'
      ],
      'Health': [
        'medicine', 'pharmacy', 'drug', 'pill', 'vitamin', 'ibuprofen', 'aspirin', 'bandage',
        'health', 'medical', 'doctor', 'dentist', 'hospital', 'clinic', 'prescription'
      ],
      'Shopping': [
        'clothes', 'shirt', 'pants', 'shoes', 'detergent', 'towel', 'soap', 'shampoo',
        'toothpaste', 'tissues', 'toilet paper', 'shopping', 'store', 'retail', 'clothing'
      ],
      'Entertainment': [
        'movie', 'cinema', 'game', 'book', 'magazine', 'concert', 'theater', 'museum',
        'park', 'zoo', 'entertainment', 'fun', 'ticket', 'show', 'event'
      ],
      'Bills': [
        'electric', 'electricity', 'water', 'gas bill', 'internet', 'phone', 'cable',
        'insurance', 'rent', 'mortgage', 'utility', 'bill', 'service'
      ]
    };
    
    for (const [category, keywords] of Object.entries(categories)) {
      if (keywords.some(keyword => desc.includes(keyword))) {
        return category;
      }
    }
    
    return 'Other';
  };

  const addMultipleTransactions = (selectedItems) => {
    const newTransactions = selectedItems.map(item => ({
      id: Date.now() + Math.random(),
      amount: item.amount,
      category: item.category,
      description: item.description,
      date: new Date().toISOString().split('T')[0],
      type: 'expense',
      isRecurring: false
    }));
    
    setTransactions(prev => [...prev, ...newTransactions]);
    setShowMultipleItemsModal(false);
    Alert.alert('Success', `Added ${selectedItems.length} transactions from receipt!`);
  };

  const getTotalExpenses = () => transactions.filter(t => t.type === 'expense').reduce((sum, t) => sum + t.amount, 0);
  const getTotalIncome = () => transactions.filter(t => t.type === 'income').reduce((sum, t) => sum + t.amount, 0);
  const getCurrentBalance = () => startingBalance + getTotalIncome() - getTotalExpenses();

  const getExpensesByCategory = () => {
    const expenses = transactions.filter(t => t.type === 'expense');
    const categoryTotals = {};
    expenses.forEach(expense => {
      categoryTotals[expense.category] = (categoryTotals[expense.category] || 0) + expense.amount;
    });
    return Object.entries(categoryTotals).map(([category, amount]) => ({ category, amount }));
  };

  const renderPieChart = () => {
    const data = getExpensesByCategory();
    const total = data.reduce((sum, item) => sum + item.amount, 0);
    const colors = ['#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF', '#FF9F40', '#FF6384'];
    
    return (
      <View style={styles.pieChartContainer}>
        <Text style={styles.chartTitle}>Expenses by Category</Text>
        {data.length === 0 ? (
          <Text style={styles.emptyText}>No expense data available</Text>
        ) : (
          data.map((item, index) => {
            const percentage = ((item.amount / total) * 100).toFixed(1);
            return (
              <View key={item.category} style={styles.chartItem}>
                <View style={[styles.colorIndicator, { backgroundColor: colors[index % colors.length] }]} />
                <Text style={styles.chartLabel}>{item.category}: ${item.amount.toFixed(2)} ({percentage}%)</Text>
              </View>
            );
          })
        )}
      </View>
    );
  };

  // OCR Settings Modal
  const renderOcrSettingsModal = () => (
    <Modal visible={showOcrSettingsModal} animationType="slide">
      <SafeAreaView style={styles.modalContainer}>
        <View style={styles.modalHeader}>
          <Text style={styles.modalHeaderTitle}>üîß OCR Engine Settings</Text>
          <TouchableOpacity onPress={() => setShowOcrSettingsModal(false)}>
            <Text style={styles.closeButton}>‚úï</Text>
          </TouchableOpacity>
        </View>
        <ScrollView style={styles.settingsContainer}>
          <Text style={styles.settingsTitle}>Choose OCR Engine for Receipt Scanning</Text>
          <Text style={styles.settingsSubtitle}>Different engines work better for different receipt types</Text>
          
          {ocrEngines.map(engine => (
            <TouchableOpacity
              key={engine.id}
              style={[styles.engineOption, selectedOcrEngine === engine.id && styles.engineOptionSelected]}
              onPress={() => {
                setSelectedOcrEngine(engine.id);
                Alert.alert('OCR Engine Changed', `Now using ${engine.name} for receipt scanning`);
              }}
            >
              <View style={styles.engineInfo}>
                <Text style={styles.engineName}>{engine.name}</Text>
                <Text style={styles.engineDescription}>{engine.description}</Text>
                <Text style={styles.engineAccuracy}>Accuracy: {engine.accuracy}</Text>
              </View>
              {selectedOcrEngine === engine.id && (
                <Text style={styles.selectedBadge}>‚úì Active</Text>
              )}
            </TouchableOpacity>
          ))}
          
          <View style={styles.ocrTipsContainer}>
            <Text style={styles.tipsTitle}>üí° OCR Tips for Better Results</Text>
            <Text style={styles.tipText}>‚Ä¢ Use good lighting when taking photos</Text>
            <Text style={styles.tipText}>‚Ä¢ Hold camera steady and parallel to receipt</Text>
            <Text style={styles.tipText}>‚Ä¢ Ensure receipt is flat and uncrumpled</Text>
            <Text style={styles.tipText}>‚Ä¢ Try different engines if one doesn't work well</Text>
            <Text style={styles.tipText}>‚Ä¢ Tesseract works best for printed receipts</Text>
            <Text style={styles.tipText}>‚Ä¢ Vision Camera is best for real-time scanning</Text>
          </View>
        </ScrollView>
      </SafeAreaView>
    </Modal>
  );

  // Receipt Detail Modal (Enhanced)
  const renderReceiptDetailModal = () => (
    <Modal visible={showReceiptDetailModal} animationType="slide">
      <SafeAreaView style={styles.modalContainer}>
        <View style={styles.modalHeader}>
          <Text style={styles.modalHeaderTitle}>üìÑ Receipt Analysis</Text>
          <TouchableOpacity onPress={() => setShowReceiptDetailModal(false)}>
            <Text style={styles.closeButton}>‚úï</Text>
          </TouchableOpacity>
        </View>
        {selectedReceipt && (
          <ScrollView style={styles.receiptDetailContainer}>
            {/* Receipt Image */}
            <View style={styles.receiptImageContainer}>
              <Image source={{uri: selectedReceipt.image}} style={styles.receiptDetailImage} />
            </View>
            
            {/* OCR Engine Info */}
            <View style={styles.receiptInfoSection}>
              <Text style={styles.sectionTitle}>ü§ñ OCR Analysis</Text>
              <View style={styles.infoRow}>
                <Text style={styles.infoLabel}>Engine Used:</Text>
                <Text style={styles.infoValue}>{selectedReceipt.ocrMethod || 'Unknown'}</Text>
              </View>
              <View style={styles.infoRow}>
                <Text style={styles.infoLabel}>Confidence:</Text>
                <Text style={styles.infoValue}>{Math.round((selectedReceipt.confidence || 0) * 100)}%</Text>
              </View>
              <View style={styles.infoRow}>
                <Text style={styles.infoLabel}>Text Length:</Text>
                <Text style={styles.infoValue}>{selectedReceipt.extractedText?.length || 0} characters</Text>
              </View>
            </View>
            
            {/* Parsed Information */}
            <View style={styles.receiptInfoSection}>
              <Text style={styles.sectionTitle}>üìã Parsed Information</Text>
              <View style={styles.infoRow}>
                <Text style={styles.infoLabel}>Merchant:</Text>
                <Text style={styles.infoValue}>{selectedReceipt.parsedData?.merchant || 'Unknown'}</Text>
              </View>
              <View style={styles.infoRow}>
                <Text style={styles.infoLabel}>Total:</Text>
                <Text style={styles.infoValue}>${selectedReceipt.parsedData?.total?.toFixed(2) || '0.00'}</Text>
              </View>
              <View style={styles.infoRow}>
                <Text style={styles.infoLabel}>Subtotal:</Text>
                <Text style={styles.infoValue}>${selectedReceipt.parsedData?.subtotal?.toFixed(2) || '0.00'}</Text>
              </View>
              <View style={styles.infoRow}>
                <Text style={styles.infoLabel}>Tax:</Text>
                <Text style={styles.infoValue}>${selectedReceipt.parsedData?.tax?.toFixed(2) || '0.00'}</Text>
              </View>
              <View style={styles.infoRow}>
                <Text style={styles.infoLabel}>Items Found:</Text>
                <Text style={styles.infoValue}>{selectedReceipt.parsedData?.items?.length || 0}</Text>
              </View>
              <View style={styles.infoRow}>
                <Text style={styles.infoLabel}>Scan Date:</Text>
                <Text style={styles.infoValue}>{selectedReceipt.scanDate}</Text>
              </View>
            </View>
            
            {/* Items Found */}
            {selectedReceipt.parsedData?.items && selectedReceipt.parsedData.items.length > 0 && (
              <View style={styles.receiptInfoSection}>
                <Text style={styles.sectionTitle}>üõí Items Detected</Text>
                {selectedReceipt.parsedData.items.map((item, index) => (
                  <View key={index} style={styles.detectedItem}>
                    <View style={styles.itemDetailInfo}>
                      <Text style={styles.itemDetailDescription}>{item.description}</Text>
                      <Text style={styles.itemDetailCategory}>Category: {item.category}</Text>
                      {item.confidence && (
                        <Text style={styles.itemDetailConfidence}>
                          Confidence: {Math.round(item.confidence * 100)}%
                        </Text>
                      )}
                    </View>
                    <Text style={styles.itemDetailAmount}>${item.amount.toFixed(2)}</Text>
                  </View>
                ))}
              </View>
            )}
            
            {/* Potential Items */}
            {selectedReceipt.parsedData?.potentialItems && selectedReceipt.parsedData.potentialItems.length > 0 && (
              <View style={styles.receiptInfoSection}>
                <Text style={styles.sectionTitle}>üîç Potential Items (Not Parsed)</Text>
                <Text style={styles.potentialItemsNote}>
                  These lines contained text but couldn't be parsed as items:
                </Text>
                {selectedReceipt.parsedData.potentialItems.map((item, index) => (
                  <View key={index} style={styles.potentialItem}>
                    <Text style={styles.potentialItemText}>
                      Line {item.lineNumber}: {item.text}
                    </Text>
                    <View style={styles.potentialItemFlags}>
                      {item.hasPrice && <Text style={styles.flagText}>üí∞ Has Price</Text>}
                      {item.hasLetters && <Text style={styles.flagText}>üìù Has Text</Text>}
                    </View>
                  </View>
                ))}
              </View>
            )}
            
            {/* Raw OCR Text */}
            <View style={styles.receiptInfoSection}>
              <Text style={styles.sectionTitle}>üìù Raw OCR Text</Text>
              <View style={styles.rawTextContainer}>
                <Text style={styles.rawText}>{selectedReceipt.extractedText}</Text>
              </View>
            </View>
          </ScrollView>
        )}
      </SafeAreaView>
    </Modal>
  );

  const renderMultipleItemsModal = () => (
    <Modal visible={showMultipleItemsModal} animationType="slide">
      <SafeAreaView style={styles.modalContainer}>
        <View style={styles.modalHeader}>
          <Text style={styles.modalHeaderTitle}>üõí Items Found on Receipt</Text>
          <TouchableOpacity onPress={() => setShowMultipleItemsModal(false)}>
            <Text style={styles.closeButton}>‚úï</Text>
          </TouchableOpacity>
        </View>
        <ScrollView style={styles.itemsContainer}>
          <Text style={styles.instructionText}>Select items to add as transactions:</Text>
          {extractedItems.map((item, index) => (
            <TouchableOpacity
              key={index}
              style={[styles.itemCard, item.selected && styles.itemCardSelected]}
              onPress={() => {
                const updatedItems = [...extractedItems];
                updatedItems[index] = { ...item, selected: !item.selected };
                setExtractedItems(updatedItems);
              }}
            >
              <View style={styles.itemInfo}>
                <Text style={styles.itemDescription}>{item.description}</Text>
                <Text style={styles.itemCategory}>Category: {item.category}</Text>
                {item.lineNumber && (
                  <Text style={styles.itemLineNumber}>Line {item.lineNumber}</Text>
                )}
                {item.confidence && (
                  <Text style={styles.itemConfidence}>
                    Confidence: {Math.round(item.confidence * 100)}%
                  </Text>
                )}
              </View>
              <Text style={styles.itemAmount}>${item.amount.toFixed(2)}</Text>
              {item.selected && <Text style={styles.checkMark}>‚úì</Text>}
            </TouchableOpacity>
          ))}
        </ScrollView>
        <View style={styles.multipleItemsActions}>
          <TouchableOpacity
            style={styles.addSelectedButton}
            onPress={() => {
              const selectedItems = extractedItems.filter(item => item.selected);
              if (selectedItems.length === 0) {
                Alert.alert('No Items Selected', 'Please select at least one item to add');
                return;
              }
              addMultipleTransactions(selectedItems);
            }}
          >
            <Text style={styles.addSelectedButtonText}>
              Add Selected ({extractedItems.filter(item => item.selected).length})
            </Text>
          </TouchableOpacity>
        </View>
      </SafeAreaView>
    </Modal>
  );

  const renderDashboard = () => (
    <ScrollView>
      <View style={styles.statsContainer}>
        <View style={[styles.statCard, {backgroundColor: '#e0f2fe'}]}>
          <View>
            <Text style={styles.statTitle}>üè¶ Starting Balance</Text>
            <TouchableOpacity onPress={() => setShowStartingBalanceModal(true)}>
              <Text style={styles.editBalanceText}>Tap to edit</Text>
            </TouchableOpacity>
          </View>
          <Text style={styles.statAmount}>${startingBalance.toFixed(2)}</Text>
        </View>
        <View style={[styles.statCard, {backgroundColor: '#dcfce7'}]}>
          <Text style={styles.statTitle}>üí∞ Total Income</Text>
          <Text style={styles.statAmount}>${getTotalIncome().toFixed(2)}</Text>
        </View>
        <View style={[styles.statCard, {backgroundColor: '#fee2e2'}]}>
          <Text style={styles.statTitle}>üí∏ Total Expenses</Text>
          <Text style={styles.statAmount}>${getTotalExpenses().toFixed(2)}</Text>
        </View>
        <View style={[styles.statCard, {backgroundColor: getCurrentBalance() >= 0 ? '#dbeafe' : '#fecaca'}]}>
          <Text style={styles.statTitle}>üí≥ Current Balance</Text>
          <Text style={[styles.statAmount, {color: getCurrentBalance() >= 0 ? '#1f2937' : '#dc2626'}]}>
            ${getCurrentBalance().toFixed(2)}
          </Text>
        </View>
      </View>

      <View style={styles.actionButtonsContainer}>
        <TouchableOpacity style={styles.actionButton} onPress={() => setShowReportsModal(true)}>
          <Text style={styles.actionButtonText}>üìä View Reports</Text>
        </TouchableOpacity>
        <TouchableOpacity style={styles.actionButton} onPress={() => setShowReceiptsModal(true)}>
          <Text style={styles.actionButtonText}>üìÑ Receipts ({scannedReceipts.length})</Text>
        </TouchableOpacity>
      </View>
      
      <View style={styles.transactionsContainer}>
        <Text style={styles.sectionTitle}>Recent Transactions</Text>
        {transactions.length === 0 ? (
          <Text style={styles.emptyText}>No transactions yet. Add your first transaction or scan a receipt!</Text>
        ) : (
          transactions.slice(-10).reverse().map(transaction => (
            <TouchableOpacity 
              key={transaction.id} 
              style={styles.transactionItem}
              onLongPress={() => {
                setSelectedTransaction(transaction);
                setShowDeleteModal(true);
              }}
            >
              <View style={styles.transactionInfo}>
                <Text style={styles.transactionDescription}>{transaction.description}</Text>
                <Text style={styles.transactionDetails}>{transaction.category} ‚Ä¢ {transaction.date}</Text>
              </View>
              <Text style={[styles.transactionAmount, {color: transaction.type === 'income' ? '#16a34a' : '#dc2626'}]}>
                {transaction.type === 'income' ? '+' : '-'}${transaction.amount.toFixed(2)}
              </Text>
            </TouchableOpacity>
          ))
        )}
      </View>

      {recurringIncome.length > 0 && (
        <View style={styles.recurringContainer}>
          <Text style={styles.sectionTitle}>Recurring Income</Text>
          {recurringIncome.map(recurring => (
            <TouchableOpacity 
              key={recurring.id} 
              style={styles.recurringItem}
              onLongPress={() => {
                Alert.alert(
                  'Delete Recurring Income',
                  `Remove "${recurring.description}"?`,
                  [
                    { text: 'Cancel', style: 'cancel' },
                    { text: 'Delete', onPress: () => deleteRecurring(recurring.id), style: 'destructive' }
                  ]
                );
              }}
            >
              <View>
                <Text style={styles.recurringDescription}>{recurring.description}</Text>
                <Text style={styles.recurringDetails}>{recurring.frequency} ‚Ä¢ ${recurring.amount.toFixed(2)}</Text>
              </View>
              <Text style={styles.recurringBadge}>üîÑ Auto</Text>
            </TouchableOpacity>
          ))}
        </View>
      )}
    </ScrollView>
  );

  const renderAddTransaction = () => (
    <ScrollView style={styles.formContainer}>
      <Text style={styles.formTitle}>Add Transaction</Text>
      
      <TouchableOpacity 
        style={[styles.scanButton, isProcessingReceipt && styles.scanButtonDisabled]} 
        onPress={scanReceipt}
        disabled={isProcessingReceipt}
      >
        <Text style={styles.scanButtonText}>
          {isProcessingReceipt ? 
            `üîÑ Processing with ${ocrEngines.find(e => e.id === selectedOcrEngine)?.name}...` : 
            `üì∑ Scan Receipt (${ocrEngines.find(e => e.id === selectedOcrEngine)?.name})`
          }
        </Text>
      </TouchableOpacity>

      {isProcessingReceipt && (
        <View style={styles.processingIndicator}>
          <Text style={styles.processingText}>
            ü§ñ {ocrEngines.find(e => e.id === selectedOcrEngine)?.name} is analyzing your receipt...
          </Text>
          <Text style={styles.processingSubtext}>Advanced text recognition in progress</Text>
        </View>
      )}
      
      <View style={styles.typeContainer}>
        <TouchableOpacity
          style={[styles.typeButton, newTransaction.type === 'expense' && styles.expenseActive]}
          onPress={() => setNewTransaction({...newTransaction, type: 'expense', isRecurring: false})}
        >
          <Text style={styles.typeText}>üí∏ Expense</Text>
        </TouchableOpacity>
        <TouchableOpacity
          style={[styles.typeButton, newTransaction.type === 'income' && styles.incomeActive]}
          onPress={() => setNewTransaction({...newTransaction, type: 'income'})}
        >
          <Text style={styles.typeText}>üí∞ Income</Text>
        </TouchableOpacity>
      </View>

      {newTransaction.type === 'income' && (
        <TouchableOpacity
          style={[styles.recurringToggle, newTransaction.isRecurring && styles.recurringToggleActive]}
          onPress={() => setNewTransaction({...newTransaction, isRecurring: !newTransaction.isRecurring})}
        >
          <Text style={styles.recurringToggleText}>
            {newTransaction.isRecurring ? 'üîÑ Recurring Income' : 'üìÖ One-time Income'}
          </Text>
        </TouchableOpacity>
      )}

      {newTransaction.isRecurring && newTransaction.type === 'income' && (
        <View style={styles.frequencyContainer}>
          <Text style={styles.label}>Frequency:</Text>
          <View style={styles.frequencyButtons}>
            {frequencies.map(freq => (
              <TouchableOpacity
                key={freq}
                style={[styles.frequencyButton, newTransaction.frequency === freq && styles.frequencyButtonActive]}
                onPress={() => setNewTransaction({...newTransaction, frequency: freq})}
              >
                <Text style={[styles.frequencyButtonText, newTransaction.frequency === freq && styles.frequencyButtonTextActive]}>
                  {freq.charAt(0).toUpperCase() + freq.slice(1)}
                </Text>
              </TouchableOpacity>
            ))}
          </View>
        </View>
      )}

      <TextInput
        style={styles.input}
        placeholder="Amount (e.g., 50.00)"
        value={newTransaction.amount}
        onChangeText={(text) => setNewTransaction({...newTransaction, amount: text})}
        keyboardType="numeric"
      />

      <View style={styles.categoryContainer}>
        <Text style={styles.label}>Category:</Text>
        <ScrollView horizontal showsHorizontalScrollIndicator={false} style={styles.categoryScroll}>
          {categories[newTransaction.type].map(category => (
            <TouchableOpacity
              key={category}
              style={[styles.categoryButton, newTransaction.category === category && styles.categoryButtonActive]}
              onPress={() => setNewTransaction({...newTransaction, category})}
            >
              <Text style={[styles.categoryButtonText, newTransaction.category === category && styles.categoryButtonTextActive]}>
                {category}
              </Text>
            </TouchableOpacity>
          ))}
        </ScrollView>
      </View>

      <TextInput
        style={styles.input}
        placeholder="Description"
        value={newTransaction.description}
        onChangeText={(text) => setNewTransaction({...newTransaction, description: text})}
      />

      <TouchableOpacity style={styles.addButton} onPress={addTransaction}>
        <Text style={styles.addButtonText}>
          {newTransaction.isRecurring ? 'Add Recurring Income' : 'Add Transaction'}
        </Text>
      </TouchableOpacity>
    </ScrollView>
  );

  return (
    <SafeAreaView style={styles.container}>
      <StatusBar backgroundColor="#4F46E5" barStyle="light-content" />
      
      <View style={styles.header}>
        <Text style={styles.headerTitle}>üí≥ Smart Expense Tracker</Text>
        <Text style={styles.headerSubtitle}>
          Multi-Engine OCR - Currently: {ocrEngines.find(e => e.id === selectedOcrEngine)?.name}
        </Text>
      </View>

      <View style={styles.content}>
        {activeTab === 'dashboard' ? renderDashboard() : renderAddTransaction()}
      </View>

      <View style={styles.tabContainer}>
        <TouchableOpacity
          style={[styles.tabButton, activeTab === 'dashboard' && styles.activeTab]}
          onPress={() => setActiveTab('dashboard')}
        >
          <Text style={[styles.tabLabel, activeTab === 'dashboard' && styles.activeTabLabel]}>üìä Dashboard</Text>
        </TouchableOpacity>
        <TouchableOpacity
          style={[styles.tabButton, activeTab === 'add' && styles.activeTab]}
          onPress={() => setActiveTab('add')}
        >
          <Text style={[styles.tabLabel, activeTab === 'add' && styles.activeTabLabel]}>‚ûï Add</Text>
        </TouchableOpacity>
      </View>

      {/* OCR Settings Modal - NEW */}
      {renderOcrSettingsModal()}

      {/* Receipt Detail Modal - ENHANCED */}
      {renderReceiptDetailModal()}

      {/* Multiple Items Modal - ENHANCED */}
      {renderMultipleItemsModal()}

      {/* Starting Balance Modal */}
      <Modal visible={showStartingBalanceModal} transparent animationType="slide">
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            <Text style={styles.modalTitle}>Set Starting Balance</Text>
            <Text style={styles.modalText}>
              Enter your current account balance to start tracking from:
            </Text>
            <TextInput
              style={styles.balanceInput}
              placeholder="0.00"
              value={balanceInput}
              onChangeText={setBalanceInput}
              keyboardType="numeric"
              autoFocus
            />
            <View style={styles.modalButtons}>
              <TouchableOpacity 
                style={styles.modalButton} 
                onPress={() => {
                  setShowStartingBalanceModal(false);
                  setBalanceInput('');
                }}
              >
                <Text style={styles.modalButtonText}>Cancel</Text>
              </TouchableOpacity>
              <TouchableOpacity 
                style={[styles.modalButton, styles.confirmButton]} 
                onPress={setInitialBalance}
              >
                <Text style={[styles.modalButtonText, styles.confirmButtonText]}>Set Balance</Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>

      {/* Delete Confirmation Modal */}
      <Modal visible={showDeleteModal} transparent animationType="slide">
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            <Text style={styles.modalTitle}>Delete Transaction</Text>
            <Text style={styles.modalText}>
              Are you sure you want to delete "{selectedTransaction?.description}"?
            </Text>
            <View style={styles.modalButtons}>
              <TouchableOpacity style={styles.modalButton} onPress={() => setShowDeleteModal(false)}>
                <Text style={styles.modalButtonText}>Cancel</Text>
              </TouchableOpacity>
              <TouchableOpacity 
                style={[styles.modalButton, styles.deleteButton]} 
                onPress={() => deleteTransaction(selectedTransaction?.id)}
              >
                <Text style={[styles.modalButtonText, styles.deleteButtonText]}>Delete</Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>

      {/* ENHANCED Receipts Modal */}
      <Modal visible={showReceiptsModal} animationType="slide">
        <SafeAreaView style={styles.modalContainer}>
          <View style={styles.modalHeader}>
            <Text style={styles.modalHeaderTitle}>üìÑ Scanned Receipts</Text>
            <TouchableOpacity onPress={() => setShowReceiptsModal(false)}>
              <Text style={styles.closeButton}>‚úï</Text>
            </TouchableOpacity>
          </View>
          <ScrollView style={styles.receiptsContainer}>
            {scannedReceipts.length === 0 ? (
              <View style={styles.emptyReceiptsContainer}>
                <Text style={styles.emptyText}>No receipts scanned yet</Text>
                <Text style={styles.emptySubtext}>Use Smart OCR to extract text from receipt photos</Text>
              </View>
            ) : (
              scannedReceipts.map(receipt => (
                <TouchableOpacity 
                  key={receipt.id} 
                  style={styles.receiptItem}
                  onPress={() => {
                    setSelectedReceipt(receipt);
                    setShowReceiptDetailModal(true);
                  }}
                >
                  <Image source={{uri: receipt.image}} style={styles.receiptImage} />
                  <View style={styles.receiptInfo}>
                    <Text style={styles.receiptMerchant}>{receipt.parsedData?.merchant || 'Unknown Store'}</Text>
                    <Text style={styles.receiptAmount}>
                      Total: ${receipt.parsedData?.total?.toFixed(2) || '0.00'}
                    </Text>
                    <Text style={styles.receiptItems}>
                      {receipt.parsedData?.items?.length || 0} items extracted
                    </Text>
                    <Text style={styles.receiptEngine}>
                      Engine: {receipt.ocrMethod || 'Unknown'}
                    </Text>
                    <Text style={styles.receiptDate}>Scanned: {receipt.scanDate}</Text>
                    <Text style={styles.receiptTapHint}>Tap to view details</Text>
                  </View>
                  <View style={styles.receiptBadge}>
                    <Text style={styles.receiptBadgeText}>
                      {Math.round((receipt.confidence || 0) * 100)}%
                    </Text>
                  </View>
                </TouchableOpacity>
              ))
            )}
          </ScrollView>
        </SafeAreaView>
      </Modal>

      {/* Reports Modal */}
      <Modal visible={showReportsModal} animationType="slide">
        <SafeAreaView style={styles.modalContainer}>
          <View style={styles.modalHeader}>
            <Text style={styles.modalHeaderTitle}>üìä Financial Reports</Text>
            <TouchableOpacity onPress={() => setShowReportsModal(false)}>
              <Text style={styles.closeButton}>‚úï</Text>
            </TouchableOpacity>
          </View>
          <ScrollView style={styles.reportsContainer}>
            {renderPieChart()}
            
            <View style={styles.summaryContainer}>
              <Text style={styles.summaryTitle}>üí∞ Financial Summary</Text>
              <View style={styles.summaryRow}>
                <Text style={styles.summaryLabel}>Starting Balance:</Text>
                <Text style={styles.summaryValue}>${startingBalance.toFixed(2)}</Text>
              </View>
              <View style={styles.summaryRow}>
                <Text style={styles.summaryLabel}>Total Income:</Text>
                <Text style={[styles.summaryValue, {color: '#16a34a'}]}>+${getTotalIncome().toFixed(2)}</Text>
              </View>
              <View style={styles.summaryRow}>
                <Text style={styles.summaryLabel}>Total Expenses:</Text>
                <Text style={[styles.summaryValue, {color: '#dc2626'}]}>-${getTotalExpenses().toFixed(2)}</Text>
              </View>
              <View style={[styles.summaryRow, styles.summaryRowFinal]}>
                <Text style={styles.summaryLabelFinal}>Current Balance:</Text>
                <Text style={[styles.summaryValueFinal, {color: getCurrentBalance() >= 0 ? '#16a34a' : '#dc2626'}]}>
                  ${getCurrentBalance().toFixed(2)}
                </Text>
              </View>
            </View>
          </ScrollView>
        </SafeAreaView>
      </Modal>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: '#f8fafc' },
  header: { backgroundColor: '#4F46E5', padding: 20, paddingBottom: 30 },
  headerTitle: { fontSize: 24, fontWeight: 'bold', color: '#fff', marginBottom: 5 },
  headerSubtitle: { fontSize: 14, color: '#E0E7FF' },
  content: { flex: 1, padding: 16 },
  statsContainer: { marginBottom: 24 },
  statCard: { padding: 16, borderRadius: 12, marginBottom: 12, flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center' },
  statTitle: { fontSize: 18, fontWeight: '600' },
  statAmount: { fontSize: 24, fontWeight: 'bold' },
  editBalanceText: { fontSize: 12, color: '#6366f1', marginTop: 2 },
  actionButtonsContainer: { flexDirection: 'row', marginBottom: 24, gap: 12 },
  actionButton: { flex: 1, backgroundColor: '#6366F1', padding: 12, borderRadius: 8, alignItems: 'center' },
  actionButtonText: { color: '#fff', fontWeight: '600' },
  transactionsContainer: { backgroundColor: '#fff', borderRadius: 12, padding: 16, marginBottom: 16 },
  recurringContainer: { backgroundColor: '#f0f9ff', borderRadius: 12, padding: 16 },
  sectionTitle: { fontSize: 18, fontWeight: '600', marginBottom: 16, color: '#1f2937' },
  emptyText: { textAlign: 'center', color: '#6b7280', fontStyle: 'italic', padding: 20 },
  emptySubtext: { textAlign: 'center', color: '#9ca3af', fontSize: 14, marginTop: 8 },
  transactionItem: { flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center', paddingVertical: 12, paddingHorizontal: 16, backgroundColor: '#f9fafb', borderRadius: 8, marginBottom: 8 },
  transactionInfo: { flex: 1 },
  transactionDescription: { fontSize: 16, fontWeight: '600', color: '#1f2937', marginBottom: 4 },
  transactionDetails: { fontSize: 14, color: '#6b7280' },
  transactionAmount: { fontSize: 16, fontWeight: 'bold' },
  recurringItem: { flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center', paddingVertical: 12, paddingHorizontal: 16, backgroundColor: '#e0f2fe', borderRadius: 8, marginBottom: 8 },
  recurringDescription: { fontSize: 16, fontWeight: '600', color: '#0369a1' },
  recurringDetails: { fontSize: 14, color: '#0284c7' },
  recurringBadge: { fontSize: 12, backgroundColor: '#0ea5e9', color: '#fff', paddingHorizontal: 8, paddingVertical: 4, borderRadius: 12 },
  formContainer: { backgroundColor: '#fff', borderRadius: 12, padding: 20 },
  formTitle: { fontSize: 20, fontWeight: '600', marginBottom: 20, color: '#1f2937' },
  scanButton: { backgroundColor: '#10b981', padding: 16, borderRadius: 8, alignItems: 'center', marginBottom: 20 },
  scanButtonDisabled: { backgroundColor: '#9ca3af' },
  scanButtonText: { color: '#fff', fontSize: 16, fontWeight: '600' },
  processingIndicator: { backgroundColor: '#f0f9ff', padding: 16, borderRadius: 8, alignItems: 'center', marginBottom: 20 },
  processingText: { fontSize: 16, fontWeight: '600', color: '#0369a1', marginBottom: 4 },
  processingSubtext: { fontSize: 14, color: '#0284c7' },
  typeContainer: { flexDirection: 'row', marginBottom: 20, gap: 12 },
  typeButton: { flex: 1, padding: 16, borderRadius: 8, borderWidth: 2, borderColor: '#e5e7eb', alignItems: 'center' },
  typeText: { fontSize: 16, fontWeight: '600' },
  expenseActive: { borderColor: '#dc2626', backgroundColor: '#fee2e2' },
  incomeActive: { borderColor: '#16a34a', backgroundColor: '#dcfce7' },
  recurringToggle: { padding: 16, borderRadius: 8, borderWidth: 2, borderColor: '#e5e7eb', alignItems: 'center', marginBottom: 20 },
  recurringToggleActive: { borderColor: '#0ea5e9', backgroundColor: '#e0f2fe' },
  recurringToggleText: { fontSize: 16, fontWeight: '600' },
  frequencyContainer: { marginBottom: 20 },
  label: { fontSize: 16, fontWeight: '600', marginBottom: 8, color: '#1f2937' },
  frequencyButtons: { flexDirection: 'row', flexWrap: 'wrap', gap: 8 },
  frequencyButton: { paddingHorizontal: 16, paddingVertical: 8, borderRadius: 20, borderWidth: 1, borderColor: '#d1d5db' },
  frequencyButtonActive: { backgroundColor: '#3b82f6', borderColor: '#3b82f6' },
  frequencyButtonText: { fontSize: 14, color: '#6b7280' },
  frequencyButtonTextActive: { color: '#fff' },
  categoryContainer: { marginBottom: 20 },
  categoryScroll: { marginTop: 8 },
  categoryButton: { paddingHorizontal: 16, paddingVertical: 8, borderRadius: 20, borderWidth: 1, borderColor: '#d1d5db', marginRight: 8 },
  categoryButtonActive: { backgroundColor: '#4f46e5', borderColor: '#4f46e5' },
  categoryButtonText: { fontSize: 14, color: '#6b7280' },
  categoryButtonTextActive: { color: '#fff' },
  input: { borderWidth: 1, borderColor: '#d1d5db', borderRadius: 8, padding: 12, fontSize: 16, marginBottom: 16, backgroundColor: '#fff' },
  addButton: { backgroundColor: '#4F46E5', padding: 16, borderRadius: 8, alignItems: 'center' },
  addButtonText: { color: '#fff', fontSize: 16, fontWeight: '600' },
  tabContainer: { flexDirection: 'row', backgroundColor: '#fff', paddingVertical: 10, paddingHorizontal: 16, borderTopWidth: 1, borderTopColor: '#e5e7eb' },
  tabButton: { flex: 1, alignItems: 'center', paddingVertical: 8, paddingHorizontal: 12, marginHorizontal: 4, borderRadius: 8, backgroundColor: '#f5f5f5' },
  activeTab: { backgroundColor: '#4F46E5' },
  tabLabel: { fontSize: 14, color: '#666' },
  activeTabLabel: { color: '#fff' },
  modalOverlay: { flex: 1, backgroundColor: 'rgba(0,0,0,0.5)', justifyContent: 'center', alignItems: 'center' },
  modalContent: { backgroundColor: '#fff', padding: 20, borderRadius: 12, margin: 20, minWidth: 300 },
  modalTitle: { fontSize: 18, fontWeight: 'bold', marginBottom: 10, textAlign: 'center' },
  modalText: { fontSize: 16, marginBottom: 20, textAlign: 'center', color: '#6b7280' },
  modalButtons: { flexDirection: 'row', gap: 12 },
  modalButton: { flex: 1, padding: 12, borderRadius: 8, alignItems: 'center', borderWidth: 1, borderColor: '#d1d5db' },
  deleteButton: { backgroundColor: '#dc2626', borderColor: '#dc2626' },
  confirmButton: { backgroundColor: '#10b981', borderColor: '#10b981' },
  modalButtonText: { fontSize: 16, fontWeight: '600', color: '#6b7280' },
  deleteButtonText: { color: '#fff' },
  confirmButtonText: { color: '#fff' },
  balanceInput: { borderWidth: 1, borderColor: '#d1d5db', borderRadius: 8, padding: 12, fontSize: 18, marginBottom: 20, textAlign: 'center' },
  modalContainer: { flex: 1, backgroundColor: '#f8fafc' },
  modalHeader: { flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center', padding: 20, backgroundColor: '#4F46E5' },
  modalHeaderTitle: { fontSize: 20, fontWeight: 'bold', color: '#fff' },
  closeButton: { fontSize: 24, color: '#fff', fontWeight: 'bold' },
  receiptsContainer: { flex: 1, padding: 16 },
  emptyReceiptsContainer: { flex: 1, justifyContent: 'center', alignItems: 'center', padding: 40 },
  receiptItem: { flexDirection: 'row', backgroundColor: '#fff', padding: 16, borderRadius: 12, marginBottom: 12, position: 'relative', elevation: 2, shadowOffset: { width: 0, height: 2 }, shadowOpacity: 0.1, shadowRadius: 4 },
  receiptImage: { width: 80, height: 80, borderRadius: 8, marginRight: 16 },
  receiptInfo: { flex: 1 },
  receiptMerchant: { fontSize: 16, fontWeight: '600', color: '#1f2937' },
  receiptAmount: { fontSize: 18, fontWeight: 'bold', color: '#dc2626', marginVertical: 4 },
  receiptItems: { fontSize: 14, color: '#6366f1', marginBottom: 4 },
  receiptEngine: { fontSize: 12, color: '#059669', marginBottom: 4 },
  receiptDate: { fontSize: 14, color: '#6b7280', marginBottom: 4 },
  receiptTapHint: { fontSize: 12, color: '#059669', fontStyle: 'italic' },
  receiptBadge: { position: 'absolute', top: 8, right: 8, backgroundColor: '#10b981', paddingHorizontal: 8, paddingVertical: 4, borderRadius: 12 },
  receiptBadgeText: { fontSize: 10, color: '#fff', fontWeight: '600' },
  reportsContainer: { flex: 1, padding: 16 },
  pieChartContainer: { backgroundColor: '#fff', padding: 20, borderRadius: 12, marginBottom: 16 },
  chartTitle: { fontSize: 18, fontWeight: '600', marginBottom: 16, textAlign: 'center', color: '#1f2937' },
  chartItem: { flexDirection: 'row', alignItems: 'center', marginBottom: 8 },
  colorIndicator: { width: 16, height: 16, borderRadius: 8, marginRight: 12 },
  chartLabel: { fontSize: 14, color: '#4b5563' },
  summaryContainer: { backgroundColor: '#fff', padding: 20, borderRadius: 12 },
  summaryTitle: { fontSize: 18, fontWeight: '600', marginBottom: 16, textAlign: 'center', color: '#1f2937' },
  summaryRow: { flexDirection: 'row', justifyContent: 'space-between', paddingVertical: 8 },
  summaryRowFinal: { borderTopWidth: 2, borderTopColor: '#e5e7eb', marginTop: 8, paddingTop: 16 },
  summaryLabel: { fontSize: 16, color: '#6b7280' },
  summaryValue: { fontSize: 16, fontWeight: '600', color: '#1f2937' },
  summaryLabelFinal: { fontSize: 18, fontWeight: '600', color: '#1f2937' },
  summaryValueFinal: { fontSize: 20, fontWeight: 'bold' },
  itemsContainer: { flex: 1, padding: 16 },
  instructionText: { fontSize: 16, fontWeight: '600', marginBottom: 16, color: '#1f2937', textAlign: 'center' },
  itemCard: { flexDirection: 'row', backgroundColor: '#fff', padding: 16, borderRadius: 12, marginBottom: 12, borderWidth: 2, borderColor: '#e5e7eb' },
  itemCardSelected: { borderColor: '#10b981', backgroundColor: '#f0fdf4' },
  itemInfo: { flex: 1 },
  itemDescription: { fontSize: 16, fontWeight: '600', color: '#1f2937', marginBottom: 4 },
  itemCategory: { fontSize: 14, color: '#6b7280' },
  itemLineNumber: { fontSize: 12, color: '#9ca3af', marginTop: 2 },
  itemConfidence: { fontSize: 12, color: '#059669', marginTop: 2 },
  itemAmount: { fontSize: 18, fontWeight: 'bold', color: '#dc2626', marginRight: 8 },
  checkMark: { fontSize: 20, color: '#10b981', fontWeight: 'bold' },
  multipleItemsActions: { padding: 16, backgroundColor: '#fff', borderTopWidth: 1, borderTopColor: '#e5e7eb' },
  addSelectedButton: { backgroundColor: '#10b981', padding: 16, borderRadius: 8, alignItems: 'center' },
  addSelectedButtonText: { color: '#fff', fontSize: 16, fontWeight: '600' },
  
  // OCR Settings Modal Styles
  settingsContainer: { flex: 1, padding: 16 },
  settingsTitle: { fontSize: 20, fontWeight: '600', marginBottom: 8, color: '#1f2937', textAlign: 'center' },
  settingsSubtitle: { fontSize: 16, color: '#6b7280', marginBottom: 24, textAlign: 'center' },
  engineOption: { backgroundColor: '#fff', padding: 20, borderRadius: 12, marginBottom: 12, borderWidth: 2, borderColor: '#e5e7eb', flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center' },
  engineOptionSelected: { borderColor: '#10b981', backgroundColor: '#f0fdf4' },
  engineInfo: { flex: 1 },
  engineName: { fontSize: 18, fontWeight: '600', color: '#1f2937', marginBottom: 4 },
  engineDescription: { fontSize: 14, color: '#6b7280', marginBottom: 4 },
  engineAccuracy: { fontSize: 14, color: '#059669', fontWeight: '600' },
  selectedBadge: { fontSize: 16, color: '#10b981', fontWeight: 'bold' },
  ocrTipsContainer: { backgroundColor: '#fffbeb', padding: 20, borderRadius: 12, marginTop: 20 },
  tipsTitle: { fontSize: 18, fontWeight: '600', color: '#92400e', marginBottom: 12 },
  tipText: { fontSize: 14, color: '#92400e', marginBottom: 8 },
  
  // Receipt Detail Modal Styles
  receiptDetailContainer: { flex: 1, padding: 16 },
  receiptImageContainer: { backgroundColor: '#fff', padding: 16, borderRadius: 12, marginBottom: 16, alignItems: 'center' },
  receiptDetailImage: { width: width - 64, height: (width - 64) * 1.3, borderRadius: 8, resizeMode: 'contain' },
  receiptInfoSection: { backgroundColor: '#fff', padding: 16, borderRadius: 12, marginBottom: 16 },
  infoRow: { flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center', paddingVertical: 8, borderBottomWidth: 1, borderBottomColor: '#f3f4f6' },
  infoLabel: { fontSize: 16, color: '#6b7280', fontWeight: '500' },
  infoValue: { fontSize: 16, color: '#1f2937', fontWeight: '600' },
  detectedItem: { flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center', paddingVertical: 12, paddingHorizontal: 16, backgroundColor: '#f0fdf4', borderRadius: 8, marginBottom: 8 },
  itemDetailInfo: { flex: 1 },
  itemDetailDescription: { fontSize: 16, fontWeight: '600', color: '#065f46', marginBottom: 4 },
  itemDetailCategory: { fontSize: 14, color: '#047857' },
  itemDetailConfidence: { fontSize: 12, color: '#059669', marginTop: 2 },
  itemDetailAmount: { fontSize: 16, fontWeight: 'bold', color: '#dc2626' },
  potentialItem: { paddingVertical: 8, paddingHorizontal: 12, backgroundColor: '#fef3c7', borderRadius: 6, marginBottom: 6 },
  potentialItemText: { fontSize: 14, color: '#92400e', marginBottom: 4 },
  potentialItemFlags: { flexDirection: 'row', gap: 8 },
  flagText: { fontSize: 10, color: '#92400e', backgroundColor: '#fbbf24', paddingHorizontal: 6, paddingVertical: 2, borderRadius: 4 },
  potentialItemsNote: { fontSize: 14, color: '#92400e', marginBottom: 12, fontStyle: 'italic' },
  rawTextContainer: { backgroundColor: '#f8fafc', padding: 16, borderRadius: 8, maxHeight: 200 },
  rawText: { fontSize: 12, color: '#4b5563', lineHeight: 18 }
});

export default App;
